{
  "articles/01_Intro_to_OSDev/1_Overview.html": {
    "href": "articles/01_Intro_to_OSDev/1_Overview.html",
    "title": "Introduction to OS Development | BrokenThorn OS Dev Tutorials",
    "keywords": "Introduction to OS Development This section introduces you to the OS development world, it's basic details and how to go about developing an OS in general, before actually starting the development of an OS, which is done in the next section (which also teaches you theory on how machines/chips work at the lowest levels). In this section we have 6 pages : Programming Computers with Programming Languages : This section introduces you to the various programming languages required to develop at the OS level. The C Programming Language : This section talks about the various features of C language you need to know to code OSes effectively. About Operating Systems and their Development : Here, you get to know a little about what OSes are and how they are built at a very basic level. Getting Setup for OS Development : This section familiarizes you with the OS dev tool chain and helps you get it setup. The History of OS Development : Here, you get to see how OSes have evolved over time, acquiring the features that we see today. Basic Concepts of an Operating system : This section introduces you to all the basic concepts/features of a modern operating system. Note This series uses C and x86 Assembly Language . It is very important to have a good understanding of both of these languages before moving on. This section includes a review of both of these languages. (Yeah, they are pretty old and used at a basic level in all machines)."
  },
  "articles/01_Intro_to_OSDev/2_Programming.html": {
    "href": "articles/01_Intro_to_OSDev/2_Programming.html",
    "title": "Programming Computers with Programming Languages | BrokenThorn OS Dev Tutorials",
    "keywords": "Programming Computers with Programming Languages If you have never programmed before, we would first like to welcome you to the world of programming and computer science. Computer scientists and software engineers use programming methods to build complex software systems that do a certain job. If you have never programmed before, you will be learning a bit of all three right from the start. This tends to make learning the first programming language difficult. However, it becomes easier to learn other programming languages over time. It is more recommended to start with a simpler language, such as Python , and build on that. Then move on to Java or C++ or C# . Java or C# is easier then C++ but it shares a lot of its syntax, so if you pick up Java first, moving to C++ would be a lot easier. In addition, by learning C++ you are also learning a a large subset of C . We recommend the following sites to learn from: cprogramming.com cplusplus.com codecademy.com YouTube also has a lot of really good videos and lectures on software engineering, computer science, and programming. Introduction to Programming The Great Debate: Which Programming Language Should You Learn First? Additional links Beginner's Resources to Learn Programming Languages Title Pro's Tinkering Guide A History of computer programming languages A beginners guide to programming languages Note These tutorials and links are quite old and there may be better places to learn stuff from at this point of time, like online playgrounds where you can quickly test code without setting up an development environment. For example, GeeksForGeeks, Tutorials Point, W3C. etc. I request you to suggest some by opening an issue in github, here . Thanks! Tip I recommend you to use an IDE (Integrated development environment) for writing code and executing it as it has a lot of benefits like syntax highlighting (colors indicating keywords and guiding you through programming), linting (Checking for all kinds of errors, warning and messages) and easier debugging/execution of computer programs. Visual Studio Code is my personal favorite. You can get it here . Though it might be worth noting that we will debug a lot of stuff manually in OS development."
  },
  "articles/01_Intro_to_OSDev/3_C_lang.html": {
    "href": "articles/01_Intro_to_OSDev/3_C_lang.html",
    "title": "The C Programming Language | BrokenThorn OS Dev Tutorials",
    "keywords": "The C Programming Language It is assumed that you already know how to program in C. This is a quick overview of some of the more important parts of the language, and also how they will work for us. Using C in Bootloaders and Kernels 16 bit and 32 bit C In the beginning, while programming your system you will find out that there is nothing at all to help you. When powered on, the system is operating in 16 bit real mode which 32 bit compilers do not support. This is the first important thing: If you want to create a 16 bit real mode OS, you must use a 16 bit C compiler. If, however, you decide that you would like to create a 32 bit OS, you must use a 32 bit C compiler. 16 bit C code is not compatible with 32 bit C code. In the series, we will be creating a 32 bit operating system. Because of this, we will be using a 32 bit C compiler. C and its executable formats A problem with C is that it does not support the ability to output flat binary programs . A flat binary program can basically be defined as a program where the entry point routine (such as main() ) is always at the first byte of the program file. Wait, what? Why would we want this? This goes back to the good old days of DOS COM programming. DOS COM programs were flat binary - they had no well-defined entry point nor symbolic names at all. To execute the program, all that needed to be done was to \"jump\" to the first byte of the program. Flat binary programs have no special internal format, so there was no standard. Its just a bunch of 1's and 0's. When the PC is powered on, the system BIOS ROM takes control. When it is ready to start an OS, it has no idea how to do it. Because of this, it runs another program - the Boot Loader to load an OS. The BIOS does not at all know what internal format this program file is or what it does. Because of this, it treats the Boot Loader as a flat binary program . It loads whatever is on the Boot Sector of the Boot Disk and \"jumps\" to the first byte of that program file and begins to simple \"execute\" the 1s and 0s. Because of this, the first part of the boot loader, also called the Boot Code or Bootloader Stage 1 cannot be in C. This is because all C compilers output a program file that has a special internal format - they can be library files, object files, or executable files. There is only one language that natively supports flat binary generation - assembly language . How to use C in a boot loader While it is true that the first part of the boot loader must be in assembly language, it is possible to use C in a boot loader. There are different ways of doing this. One way is used in both Windows and our own in-house operating system, Neptune. We combine an assembly stub program and the C program in a single file. The assembly stub program sets up the system and calls our C program. Because both of these programs are combined into a single file, Stage 1 only needs to load a single file - which in turn loads both our stub program and C program. This is one method - there are others. Most real boot loaders use C, including GRUB, Neptunes boot loader, Microsoft's NTLDR and Boot Manager. Because we are using 32 bit C, there are also ways that will allow us to mix 16 bit code with our 32 bit C code. Doing this can be fairly complicated and tricky to implement. Because of this, we stick with just using assembly language in the series boot loader. We might cover an advanced tutorial later that can describe methods of using C later on however if the reader demand is great enough. Calling a C kernel When the boot loader is ready, it loads and executes our C kernel by calling its entry point routine. Because the C program follows a specific internal format, the boot loader must know how to parse the file and locate the entry point routine to call it. In the series, we cover how to do this a little later. This allows us to use C for the kernel and other libraries that we build. Pointers in C Introduction Because you are reading this, I assume that you are already good with pointers. In system software, they are used everywhere since we are constantly referring to memory locations in various parts of the system memory (RAM, hard-disk, CPU caches). Because of this, it is very important to master pointers. A pointer is simply a variable that holds the address of something. To define a pointer, we use the * operator: char* pointer; Remember that a pointer stores an \"address\". We do not set the above pointer to anything, so what \"address\" does it refer to? The above code is an example of a wild pointer. A wild pointer is a pointer that can point to anything. Remember that C does not initialize anything for you . Because of this, the above pointer can point to anything. Another variable, address 0, some other piece of data, your own code, a hardware address. The Physical Address Space (PAS) The Physical Address Space (PAS) defines all of the \"Addresses\" that you can use. These addresses can refer to anything that is inside of the PAS. This includes physical memory (RAM), hardware devices, or even nothingness. This is very different then in applications programming in a protected mode OS, like Windows, where all \"addresses\" are memory. Here is an example. In applications programming , the following would cause a segmentation fault error and crash your program: char* pointer = 0; *pointer = 0; This creates a pointer and points it to memory address 0, which you do not \"own\". Because of this, the system does not allow you to write to it. Now, if we try that same exact code again in our future C kernel ... no crash! Instead of crashing, it overwrites the first byte of the Interrupt Vector Table (IVT) which resides at that location in memory. From this, we can make a few important differences: The system will not crash if you use null pointers Pointers can point to any \"address\" in the PAS, which may or may not be memory If you attempt to read from a memory address that does not exist, you will get garbage (whatever was on the system data bus at that time). An attempt to write to a memory address that does not exist does nothing. Writing to a non existent memory address and immediately reading it back may or may not give you the same result just \"written\"...It depends if the data \"written\" is still on the data bus or not. Things get more interesting here. ROM devices are mapped into the same PAS. This means that it is possible for you to read or write certain parts of ROM devices using pointers. A good example of a ROM device is the system BIOS. Because ROM devices are read only, writing to a ROM device is the same effect as writing to a non existent memory location. You can read from ROM devices, however. Other devices may also be mapped into the PAS. This depends on your system configuration. This means reading or writing different parts of the PAS may yield different types of results. As you can tell, pointers play a much bigger role in systems programming then they did in the applications programming world. It may be easier to think of pointers not as a \"variable that points to a memory location\" but rather a \"variable that points to an address in the PAS\" as it may or may not be RAM. Dynamic Memory Allocation In the application programming world, you would normally call malloc() and free() or new and delete to allocate a block of memory from the heap. This is different in the system programming world. To allocate memory, we do this: char* pointer = (char*)0x5000; That is it. Cool, huh? Because we have control over everything, we can just point a pointer to some address in the PAS (would have to be RAM) and say \"there's our new buffer of 1024 bytes\" or something like that. The important thing here is that there is no dynamic memory allocation. Dynamic memory allocation in C and C++ are system services and require an OS to be running. But, wait! Aren't we developing our own OS? That is the problem 😁 We will need to write our own memory management services and routines in order to be able to provide a malloc() and free() or new and delete . Until then, the only way to \"allocate\" a buffer is to use some unused location in the address space. Inline Assembly (Using assembly inside a C Program) There are some things that C cannot natively do. We will be needing to use assembly language for system services and talking to hardware devices. Most compilers provide a keyword that allows inline assembly. For example, Microsoft Visual C++ uses _asm: _asm cli ; disable interrupts> We can also have blocks of assembly code: _asm { cli hlt } Standard Library and the Run Time Library (RTL) You can use external libraries - if and only if those routines do not use system services. Anything like printf() , scanf() , memory routines, or, virtually everything but the bare minimum routines can be used. About 90% of it will be needed to be rewritten for your own OS, so it is best to write your own. The RTL is the set of services and routines that your application program uses at run time. These, by their nature, require an OS to already be running and to support them. Because of this, you will need to develop your own RTL. The startup RTL code is responsible for calling C++ constructors and destructors . If you are wanting to use C++, you must develop the RTL code to support it. This uses compiler extensions. In the series, we develop both an RTL that supports C and C++ features as well as a basic standard library as needed. Fixing Errors (Debugging) Because there is no printf() or any way to use a debugger, what are you going to do if something is not working? The series uses (and explains) how to use the Bochs Debugger , which is a debugger that comes with the Bochs emulator . This can be used to run your OS as well as for aiding in fixing most of the more common errors that you may run into. The only other way is to develop your own routines that will allow you to output information. At the most this might be able to tell you how far the software gets to before crashing. This is certainly going to be an exciting, one-of-its-kind journey! Next, we will enter the waters of OS Development and setup the tool chain to develop OSes."
  },
  "articles/01_Intro_to_OSDev/4_About_OSDev.html": {
    "href": "articles/01_Intro_to_OSDev/4_About_OSDev.html",
    "title": "About Operating Systems and their Development | BrokenThorn OS Dev Tutorials",
    "keywords": "About Operating Systems and their Development Operating systems can be a very complex topic. Learning how operating systems work can be a great learning experience. The purpose of this series is to teach the black art of Operating System (OS) Development, from the ground up. Whether you want to make your own OS, or simply to learn how they work, this series is for you. About Operating Systems An Operating System provides the basic functionality, look, and feel, for a computer. The primary purpose is to create a workable Operating Environment for the user. An example of an Operating System is Windows, Linux, and Macintosh. If you have never programmed before, computer programming is designing and writing software, or programs, for the computer to load and execute. However, the Operating System needs to be designed with this functionality. An Operating System is not a single program, but a collection of software that work and communicate with each other. This is what I mean by \"Operating Environment\". Because Operating Systems are a collection of software, in order to develop an Operating System, one must know how to develop software. That is, one must know computer programming. If you have never programmed before, take a look at the Requirements section below, and look no further. This section will have links to good tutorials and articles that could help you to learn computer programming with C++ and 80x86 Assembly Language. Knowledge Requirements for developing OSes The C Programming Language Using a high level language, such as C, can make OS development much easier. The most common languages that are used in OS development are C, C++, and Perl. Do not think these are the only languages that may be used; It is possible in other languages. I have even seen one with FreeBASIC! Getting higher level languages to work properly can also make it harder to work within the long run, however. C and C++ are the most common, with C being the most used. C, as being a middle level language, provides high level constructs while still providing low level details that are closer to assembly language, and hence, the system. Because of this, using C is fairly easy in OS development. This is one of the primary reasons why it is the most commonly used: Because the C programming language was originally designed for system level and embedded software development. Here are some references to learn C Language from. The x86 Assembly Language 80x86 Assembly Language is a low level programming language. Assembly Language provides a direct one to one relation with the processor machine instructions, which make assembly language suitable for hardware programming. Assembly Language, as being low level, tend to be more complex and harder to develop in, then high level languages like C. Because of this, and to aid in simplicity, We are only going to use assembly language when required, and no more. Assembly Language is another complex language that can take a book to fill. If you do not know x86 Assembly Language, the following may help: Here is a link to AT&T syntax: AT&T syntax: https://gist.github.com/DmitrySoshnikov/c67cbde1cceb0d6a194830b41baa5c8b inline assembly: https://www.codeproject.com/articles/15971/using-inline-assembly-in-c-c Intel vs ATT syntax: https://www.nayuki.io/page/a-fundamental-introduction-to-x86-assembly-programming inline assembly: https://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html assembly language (Intel syntax / NASM): https://www.tutorialspoint.com/assembly_programming/ Note The above links are not from the original author. They are links from which I learnt the x86 assembly language. They are pretty good resources for any type of coding you will do in x86 asm . That is all you need to know; Everything else I'll teach along the way. Important From here on out, I will NOT be explaining C or x86 Assembly Language concepts. I will however, still explain new instructions that you may not be familiar with, such as lgdt , and the use of sti , cli , bt , cpuid and some others. Hope you like it!"
  },
  "articles/01_Intro_to_OSDev/5_OSDev_setup.html": {
    "href": "articles/01_Intro_to_OSDev/5_OSDev_setup.html",
    "title": "Getting Setup for OS Development | BrokenThorn OS Dev Tutorials",
    "keywords": "Getting Setup for OS Development In developing low level code, we will need specialized low level software to help us out. Some of these tools are not needed, however, they are highly recommended as they can significantly aid in development. NASM - The Assembler The Netwide Assembler (NASM) can generate flat binary 16bit programs, while most other assemblers (Turbo Assembler (TASM), Microsoft's Macro Assembler (MASM)) cannot. During the development of the OS, some programs must be pure binary executables. Because of this, NASM is a great choice to use. You can download NASM from here . Microsoft Visual C++ Because portability is a concern, most of the code for our operating system will be developed in C. During OS Development, there are some things that we must have control over that not all compilers may support, however. For example, say good bye to all runtime compiler support (templates, exceptions) and the good old standard library! Depending on the design of your system, you may also need to support or change more detailed properties: Such as loading at a specific address, adding your own internal sections in your programs' binary, etc. The basic idea is that not all compilers out there are capable of generating operating system machine/binary code. I will be using Microsoft Visual C++ for developing the system. However, it is also possible to develop in other compilers such as DJGPP, GCC or even Cygwin. Cygwin is a command shell program that is designed to emulate Linux command shell. There is a GCC port for Cygwin. You can download Visual Studio here and then select Desktop development with C++ workload during it's installation. Tool for Copying the Boot Loader The bootloader is a pure binary program that is stored in a single 512 byte sector. It is a very important program as it is impossible to create an OS without it. It is the very first program of your OS that is loaded directly by the BIOS, and executed directly by the processor. We can use NASM to assemble the program, but how do we get it on a floppy disk? We cannot just copy the file. Instead, we have to overwrite the boot record that Windows places (after formatting the virtual/real disk) with our bootloader. Why do we need to do this? Remember that the BIOS only looks at the bootsector when finding a bootable disk. The bootsector, and the \"boot record\" are both in the same sector! Hence, we have to overwrite it. There are a lot of ways we can do this. Here, I will present two. If you are unable to get one method working on your system, our readers may try the other method. Warning Do Not attempt to play with the following software until I explain how to use it. Using this software incorrectly can corrupt the data on your disk or make your PC unbootable. PartCopy - Low Level Disk Copier PartCopy allows the copying of sectors from one drive to another. PartCopy stands for \"Partial copy\". Its function is to copy a certain number of sectors from one location to another, to and from a specific address. You can download it from here . Windows DEBUG Command Windows provides a small command line debugger that may be used through the command line. There are quite a bit of different things that we can do with this software, but all we need it to do is copy our boot loader to the first 512 bytes on disk. Go to the command prompt, and type debug . You will be greeted by a little prompt (-): C:\\Documents and Settings\\Michael>debug - Here is where you enter your commands. h is the help command, q is the quit command. The w (write) command is the most important for us. You can have debug load a file into memory such as, say, our boot loader: C:\\Documents and Settings\\Michael>debug boot_loader.bin - This allows us to perform operations on it. (We can also use debugs L (Load) command to load the file is we wanted to). In the above example, boot_loader.bin will be loaded at address 0x100. To write the file to the first sector of our disk, we need to use the W (Write) command which takes the following form: W [address] [drive] [firstsector] [number] Okay... so let's see: The file is at address 0x100. We want the floppy drive (Drive 0). The first sector is the first sector on the disk (sector 0) and the number of sectors is ehm... 1. Putting this together, this is our command to write boot_loader.bin to the boot sector of a floppy: C:\\Documents and Settings\\Michael>debug boot_loader.bin -w 100 0 0 1 -q VFD - Virtual Floppy Drive Weather you have a floppy drive or not, this program is very useful. It can simulate a real floppy drive from a stored floppy image, or even in RAM. This program creates a virtual floppy image, allows formatting, and copying files (Such as, your kernel perhaps?) directly using Windows Explorer. You can download it from here . Bochs Emulator - PC Emulator and Debugger You pop in a floppy disk into a computer, hoping that it works. You boot your computer and look in awe at your greatest creation! ...Until your floppy motor dies out because you forgot to send the command to the controller in your bootloader. When working with low level code, it is possible to destroy hardware if you are not careful. Also, to test your OS, you will need to reboot your computers hundreds of times during development. Also, what do you do if the computer just reboots? What do you do if your Kernel crashes? Because there is no debugger for your OS, it is virtually impossible to debug. The solution? A PC Emulator. There are plenty available, two of them being VMWare and Bochs Emulator. I will be using Bochs and Microsoft Virtual PC for testing. You can download Bochs from here . Note You do not need to know how to use the software I listed. I will explain how to use them as we start using them. Tip If you would like to run your system on a real computer that does not have a floppy drive, it is still possible to boot from CD even though it is a floppy image. This is done through Floppy Emulation that which most of BIOSs support. Simply get a CD burning software (I personally use MagicISO) that can create a bootable ISO from a floppy image. Then, simply burn the ISO image to a CD and it should work. The Build Process There are a lot of tools listed above. To better understand how they can be useful, we should take a look at the entire build process of the OS: Setting everything up Use VFD to create and format a virtual floppy image to use. Set up Bochs Emulator to boot from the floppy image. The bootloader Assemble the bootloader with NASM to create a flat binary program. Use PartCopy or the DEBUG command to copy the bootloader to the bootsector of the virtual floppy image. The Kernel (And basically all other programs) Assembly and/or compile all sources into an object format (Such as ELF or PE) that can be loaded and executed by the boot loader. Copy kernel into floppy disk using Windows Explorer. Test it! Using Bochs emulator and debugger, using a real floppy disk, or by using MagicISO to create a bootable CD. Some of the terms and concepts listed here may be new to you. Do not worry!😀 everything will be explained in the upcoming sections. The purpose of this section is to create a stepping stone for the rest of the series. This page provides a basic introduction, and a listing of the tools we will be using. I will explain how to use these programs as we need to, so you do not need a tutorial on anything listed here besides what has been listed in the Requirements page. We also have taken a look at the building process for developing an operating system. For the most part, its fairly simple, however it provides a way to see when the programs listed will be used. In the next page we are going to go back in time from the first Disk Operating System (DOS) and take a little tour through history. We will also look at some basic OS concepts."
  },
  "articles/01_Intro_to_OSDev/6_OSDev_History.html": {
    "href": "articles/01_Intro_to_OSDev/6_OSDev_History.html",
    "title": "The History of OS Development | BrokenThorn OS Dev Tutorials",
    "keywords": "The History of OS Development In this page, we are going to look at operating systems in a different way. We will go back in time to look at the history of operating systems. You will find there are many similarities between these vintage operating systems. These similarities will then be classified into the basic features operating systems have in common; which will also be a part of you own OS. Most of todays operating systems are graphical. These graphical user interfaces (GUI), however, provide a large abstraction layer to what is really going on in an OS. Many operating systems concepts date back to when programs were written on tape. A lot of these concepts are still in play today. Prehistory - The Need for Operating Systems Prior to the 1950s, all programs were on punch cards. These punch cards represented a form of instructions, which would control every faucet of the computer hardware. Each piece of software would have full control of the system. Most of the time, the software would be completely different with each other. Even the versions of a program. The problem was that each program was completely different. They had to always be rewritten from scratch. There was no common support for the software, so the software had to communicate directly with the hardware. This also made portability and compatibility impossible. During the realm of Mainframe computers, creating code libraries became more feasible. While it did fix some problems, such as two versions of software being completely different, each software still had full control of hardware. If new hardware came out, the software will not work. If the software crashed, it would need to be debugged using light switches from a control panel. The idea of an interface between hardware and programs came during the Mainframe era. By having an abstraction layer to the hardware, programs will no longer need to have full control, but instead they all would use a single common interface to the hardware. What is this ultra cool interface? Why, its that sweet cuddly (sometimes nasty) thing we call an Operating System! 😀 1950s The first real operating system recorded, according to Wikipedia, is the GM-NAA I/O. The SHARE Operating System was a successor of the GM-NAA I/O. SHARE provided sharing programs, managed buffers, and was the first OS to allow the execution of programs written in Assembly Language. SHARE became the standard OS for IBM computers in the late 1950s. The SHARE Operating System (SOS) was the first OS to manage buffers, provide program sharing, and allow execution of assembly language programs. \"Managing Buffers\" relate to a form of \"Managing Memory\". \"Program Sharing\" relates to using libraries from different programs. The two important things to note here are that, since the beginning of time (Not really 😂), Operating Systems have been responsible for Memory Management and Program Execution/Management Because this isn't the history of the world (nor that of computers) that I am narrating, lets jump ahead to the good old DOS. 1964 - DOS/360 and OS/360 DOS/360 (or just \"DOS\") was a Disk Operating System was originally announced by IBM to be released on the last day of 1964. Do to some problems, IBM was forced to ship DOS/360 with 3 versions, each released June 1966. The versions were: BOS/360 - 8KB Configuration. DOS/360 - 16KB Configuration with disk. TOS/360 - 16KB Configuration with tape. A couple of important things to note is that DOS/360 offered no Multitasking , and no Memory Protection . The OS/360 was being developed about the same time by IBM. The OS/360 used \"OS/MFT\" (Multiple Fixed Transactions) to support multiple programs, with a Fixed Base Address . With OS/MVT (Multiple Variable Transaction), it can support varies program sizes. Now we have a few more interesting words - Multitasking, Memory Protection, and Fixed Base Address . Adding to before, we also have Program execution and Memory Management . 1969 - Unix comes along The Unix Operating System was originally written in C. Both C and Unix were originally created by AT&T. Unix and C were freely distributed to government and academic institutions, causing it to be ported to a wider variety of machine families then any other OS. Unix is a multiuser , Multitasking Operating System. Unix includes a Kernel , File System and a Command Shell . There are a lot of Graphical User Interfaces (GUI) that uses the Command Shell to interact with the OS, and provide a much friendlier and nicer look. 1982 - Commodore DOS Commodore DOS (CBM DOS) was used with Commodore's 8 bit computers. Unlike the other computers before or since-which booted from disk into the systems memory at startup, CBM DOS executed internally within the drive-internal ROM chips, and was executed by an MOS 6502 CPU. 1985 - Microsoft Windows 1.0 The first Windows was a DOS application. Its \"MSDOS Executive\" program allows the running of a program. None of the \"Windows\" could overlap, however, so each \"window\" was displayed side to side. It was not very popular. 1987 - Microsoft Windows 2.0 The second version of Windows was still a DOS Graphical Shell , but supported overlapping windows, and more colors. However, do to the limitation of DOS, it was not widely used. Note DOS is a 16 bit operating system. During this time frame, DOS had to reference memory through Linear Addressing, and disks through LBA (Linear Block Addressing). Because the x86 platform is backward compatible, When the PC boots it is in 16 bit mode (Real Mode), and still has LBA. More on this later. Due to 16 bit mode limitations, DOS could not access more then 1 MB of memory. This is solved, today, by enabling the 20th address line through the Keyboard Controller. We will go over this later. Because of this 1 MB limitation, Windows was far to slow, which was one primary reason of it being unpopular. 1987 - Microsoft Windows 3.0 Windows 2.0 was completely redesigned. Windows 3.0 was still a DOS Graphical Shell, however it included A \"DOS Extender\" to allow access to 16 MB of memory, over the 1 MB limit of DOS. It is supports multitasking with DOS programs. This is the Windows that made Microsoft big. It supports resizable windows, and movable windows. Windows in relation to OS Developers I have seen quite a few beginning OS developers want to develop the next Windows. While it is possible, it is extremely difficult, and is impossible with a one person team. Take a look at the above picture again. Remember that it is a graphical shell over a command shell , being executed by a Kernel . Also, remember that even Windows had to start here. The Command Shell was DOS. the Graphical Shell was \"Windows\". In the next page, we will consolidate all the features these OSes share to help define what an OS consists of."
  },
  "articles/01_Intro_to_OSDev/7_Basic_OS_Concepts.html": {
    "href": "articles/01_Intro_to_OSDev/7_Basic_OS_Concepts.html",
    "title": "Basic Concepts of an Operating system | BrokenThorn OS Dev Tutorials",
    "keywords": "Basic Concepts of an Operating system Looking back though our small trip to memory lane brings some important new terms with it. So far, we only gave \"operating system\" a small definition. The previous page should help us in defining a better, more descriptive definition of what an operating system is. Since we now know what features most OSes have in common, to help define them better, lets put the above bolded terms into a list: Memory Management Program Management Multitasking Memory Protection Fixed Base Address Multi-user presence Kernel File System Command Shell Graphical User Interface (GUI) Graphical Shell Linear Block Addressing (LBA) Bootloader (From the previous tutorial) Memory Management Memory Management refers to: Dynamically giving and using memory to and from programs that request it. Implementing a form of Paging , or even Virtual Memory . Insuring the OS Kernel does not read or write to unknown or invalid memory. Watching and handling Memory Fragmentation . Program Management This relates closely with Memory Management. Program Management is responsible for: Insuring the program doesn't write over another program. Insuring the program does not corrupt system data. Handle requests from the program to complete a task (such as allocate or deallocate memory). Multitasking Multitasking refers to: Switching and giving multiple programs a certain timeframe to execute. Providing a Task Manager to allow switching (Such as Windows Task Manager). TSS (Task State Segment) switching. Another new term! Executing multiple programs simultaneously. Memory Protection This refers to: Accessing an invalid descriptor in protected mode (Or an invalid segment address) Overwriting the program itself. Overwriting a part or parts of another file in memory. Fixed Base Address A \"Base Address\" is the location where a program is loaded in memory. In normal applications programming, you wouldn't normally need this. In OS Development, however, you do. A \"Fixed\" Base Address simply means that the program will always have the same base address each time it is loaded in memory. Two example programs are the BIOS and the Bootloader. Multiuser This refers to: Login and Security Protection. Ability of multiple users to work on the computer. Switching between users without loss or corruption of data. Kernel The Kernel is the heart of the Operating System. It provides the basic foundation, memory management, file systems, program execution, etc. We will take a closer look at the kernel very soon, don't worry 😀 File System In OS Development, there is no such thing as a \"file\". Everything could be pure binary code (from the bootsector); from the start. A File System is simply a specification that describes information regarding files. In most cases, this refers to Clusters, Segments, segment address, root directories, etc. the OS has to find the exact starting address of the file in order to load it. File Systems also describe file names. There are external and internal file names. For example, the FAT12 specification states a filename can only be 11 characters. No more, no less. Seriously. This means the filename \"KRNL.sys\", for example, will have the internal file name \"KRNL SYS\" . We will be using FAT12 and be discussing it in detail later. Command Shell A Command Shell sits on top the Kernel as a separate program. The Command Shell provides basic input and output through the use of typing commands. The Command Shell uses the Kernel to help with this, and complete low level tasks. Graphical User Interface (GUI) The Graphical User Interface (GUI) simply refers to the graphical interface and interactions between the Graphical Shell and the user. Graphical Shell The Graphical Shell provides video routines and low level graphical abilities. It normally will be executed by the Command Shell. (As in Windows 1.0,2.0, and 3.0). Usually this is automatic these days, however. Linear Block Addressing (LBA) Operating Systems have control over every single little byte in memory . Linear Addressing refers to directly accessing linear memory. For example: mov ax, [0x09000] ; There is no such thing as Access Violations in OS Development This is a good thing, but is also a very bad thing. For example: mov bx, [0x7bff] ; or some other address less then 7c00h mov cx, 10 .loop1: mov [bx], 0x0 ; clear bx inc bx ; go to next address loop .loop1 ; loop until cx=0 The above code seems harmless. However, if the above code was found in a bootloader, the above code will overwrite itself by 10 bytes. Ouch. The reason is that bootloaders are loaded with a Fixed address of 0x7c00:0, and the above code starts writing from 07bffh: One byte before 07c00h. Bootloader From the previous page, we know that the bootloader is loaded by the BIOS, and is the very first program to execute on power on. The bootloader is loaded by the BIOS at absolute address 0x7c00:0 . After loading, the CS:IP (which you will learn about soon) is set to your bootloader, and the bootloader takes full control. Important A Floppy Sector is only 512 bytes in size. Remember that the bootloader has to fit in a single bootsector. What does this mean? The bootloader is very limited in size, and cannot exceed 512 bytes. Most of the time, the bootloader will either just load and execute the kernel, or a Second Stage Bootloader . Conclusion In the next section we will explore the creation of a stage 1 bootloader by delving into the theory and code behind the process of booting up a machine and executing the bootloader."
  },
  "articles/02_Bootloader_Stage_1/1_Overview.html": {
    "href": "articles/02_Bootloader_Stage_1/1_Overview.html",
    "title": "this is overview | BrokenThorn OS Dev Tutorials",
    "keywords": "this is overview"
  },
  "articles/02_Bootloader_Stage_1/2_Booting_Process.html": {
    "href": "articles/02_Bootloader_Stage_1/2_Booting_Process.html",
    "title": "Booting Process | BrokenThorn OS Dev Tutorials",
    "keywords": "Booting Process"
  },
  "articles/03_Bootloader_Stage_2/1_Overview.html": {
    "href": "articles/03_Bootloader_Stage_2/1_Overview.html",
    "title": "this is overview | BrokenThorn OS Dev Tutorials",
    "keywords": "this is overview"
  },
  "articles/51_Using_the_Toolchain/1_Overview.html": {
    "href": "articles/51_Using_the_Toolchain/1_Overview.html",
    "title": "this is overview | BrokenThorn OS Dev Tutorials",
    "keywords": "this is overview"
  },
  "articles/About/About_BrokenThorn.html": {
    "href": "articles/About/About_BrokenThorn.html",
    "title": "About BrokenThorn Entertainment | BrokenThorn OS Dev Tutorials",
    "keywords": "About BrokenThorn Entertainment Most of the contents of this tutorial have been written by \"BrokenThorn Entertainment Co.\" about a decade ago. Click here to visit their website. To learn more about the creators of the tutorials, go here . This is the original website where the project exists. Contacts You can contact the author at: webmaster@brokenthorn.com neon6000@aol.com (preferred) You might also be able to catch the editor on #osdev in either QuakeNet or FreeNode IRC networks however it is not guaranteed. Legal The BrokenThorn OS Dev tutorials websites legal statement as of 13-July-2020: The provided material in the OS Development Series is released to the public domain. Any users of this web site are free to use any of the material described within these chapters as they wish so long as the material is not duplicated in any form that violates copyright law. The OS Development Series, and the chapters, are a work in progress. Copyright 2009 BrokenThorn Entertainment, Co."
  },
  "articles/About/About_This_Project.html": {
    "href": "articles/About/About_This_Project.html",
    "title": "About This Project | BrokenThorn OS Dev Tutorials",
    "keywords": "About This Project These are a series of tutorials and articles about computers and operating systems, which intend to demonstrate and teach operating system development from the ground up. The series focuses on a new direction in developing an operating system from scratch , whilst describing architectures and concepts that are in system-level programming , providing the most comprehensive guide in operating systems and computer systems development. This project was created by Enygmator to provide a better user interface to navigate the OS dev series created by BrokenThorn entertainment and at the same time correct any grammatical, spelling or conceptual errors in the original tutorials. Note This project in no way intends to infringe on the copyright of the series and fully attributes the original documentation/tutorial series to \"BrokenThorn entertainment Co.\". I am not the author of this series (which has been created with lots of expertise and effort by the original author). I'd like to thank the original creators for creating such a great starting point for systems developers. This is certainly the best starting point resource out there (created with a lot of effort), which I myself referred to during a \"conceptual\" project called Lantern OS which you can have a look at [here] (insert link here/coming soon) which has its own documentation (unlike this series, its documentation is not a tutorial, but is actually the software (OS) documentation). Contributions I would love to receive contributions to the tutorials, not only in terms of new, helpful content, but also in correcting errors, making things clearer with better wording, more links and references to other resources that might be helpful to the community members, along with improvements in the UI (if you are experienced in using DocFX, which is what we use to generate this website from DFM i.e. DocFX Flavoured MArkdown) and ANY OTHER THING that might be USEFUL! Click here to get to know more about contributing to the project. This project is open source and is present on github . Click here to submit feedback or log issues with the site or its content, or even if you want to suggest features or maybe hold a discussion on a topic (the contents of a page) License I created this project, but I certainly didn't write any of the documentation/tutorial series, whose contents belong to \"BrokenThorn entertainment Co.\". Thus, the actual content license belongs to them. You can view their Privacy policy here and their Terms of use here . You can read their own legal statement here . The provided Privacy policy and Terms of use links don't seem to work. Until I can confirm the legal structure to use with \"BrokenThorn entertainment Co.\", in interest of the community, I have assigned it a AGPL-3.0 license whose details you may read in the LICENSE file, or a shorter version here , which requires that whatever changes you make to this project to distribute publicly, you must share the source code which can in turn help our community make better software and learn more effectively. For more information, visit the github page of this project here"
  },
  "articles/Forums.html": {
    "href": "articles/Forums.html",
    "title": "Forums | BrokenThorn OS Dev Tutorials",
    "keywords": "Forums Until there is a better place (like the way microsoft does stuff in github or some kind of StackOverflow integration), you can visit the official forums of BrokenThorn Entertainment here ."
  },
  "articles/More_articles.html": {
    "href": "articles/More_articles.html",
    "title": "Where is the rest of the tutorial | BrokenThorn OS Dev Tutorials",
    "keywords": "Where is the rest of the tutorial This project/website is still in its making and will be completed within the next few weeks, so hang tight! You can meanwhile visit the official site for all the original articles."
  },
  "index.html": {
    "href": "index.html",
    "title": "Operating Systems Development | BrokenThorn OS Dev Tutorials",
    "keywords": "Operating Systems Development Welcome! These are a series of tutorials and articles about computers and operating systems, which intend to demonstrate and teach operating system development from the ground up. The series focuses on a new direction in developing an operating system from scratch , whilst describing architectures and concepts that are in system-level programming , providing the most comprehensive guide in operating systems and computer systems development. The goal of this series is to provide the most comprehensive guide in operating systems and computer systems, while attempting to cover every bit of it (pun intended). You can get to know more about this project here . Disclaimer This website aims to provide a better user interface to navigate the OS development series created by \"BrokenThorn entertainment\" and at the same time correct any grammatical, spelling or conceptual errors in the original tutorials. Note This project in no way intends to infringe on the copyright of the series and fully attributes the original documentation/tutorial series to \"BrokenThorn entertainment Co.\". I am not the author of this series (which has been created with lots of expertise and effort by the original author). I'd like to thank the original creators for creating such a great starting point for systems developers. This is certainly the best starting point resource out there (created with a lot of effort), which I myself referred to during a \"conceptual\" project called Lantern OS which you can have a look at [here] (insert link here/coming soon) which has its own documentation (unlike this series, its documentation is not a tutorial, but is actually the software (OS) documentation). More about this website This project was created by Enygmator to provide a better user interface to navigate the OS dev series created by BrokenThorn entertainment and at the same time correct any grammatical, spelling or conceptual errors in the original tutorials. This project is therefore, open source and is present on github . Click here to view the repo. Please do visit the github project page to get to know more about this project. To submit feedback (issues and suggestions) or to contribute to this project directly, visit the project page on github."
  }
}